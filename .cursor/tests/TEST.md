# Plan de Pruebas: yt_transcriber

## Tabla de Casos de Prueba

| Test ID | Descripción                                                                 | Precondiciones                                                                      | Pasos (Payload para POST /transcribe)                                                                                             | Resultado Esperado                                                                                                                                                              | Resultado Actual | Estado (P/F) | Notas/Resolución                                                                                                                                                                                                      |
| :------ | :-------------------------------------------------------------------------- | :---------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | :--------------- | :----------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **ÉXITO** |                                                                             |                                                                                     |                                                                                                                                   |                                                                                                                                                                                 |                  |              |                                                                                                                                                                                                                   |
| TC_001  | Transcripción exitosa de un video corto de YouTube (Español)                | Servidor FastAPI corriendo. Directorios `temp_files` y `output_transcripts` existen. | `{"youtube_url": "https://www.youtube.com/watch?v=Y-Jy_ClFIos", "title": "midutest_tc001"}`                           | Código 200. Respuesta JSON con `filename`, `transcription_length`, `detected_language`. Archivo `output_transcripts/midutest_tc001_vid_Y-Jy_ClFIos_job_XYZ.txt` creado. Archivos de video y audio WAV en `temp_files/` eliminados.     | Código 200. `output_transcripts/midutest_tc001_vid_Y-Jy_ClFIos_job_XYZ.txt` creado y verificado. Archivos temporales eliminados. | P            | Payload usa `title`. Respuesta incluye idioma. Nombre de archivo final incluye video_id y job_id.                                                                                                                                                                    |
| TC_002  | Transcripción exitosa de un video corto de YouTube (Inglés)                 | Servidor FastAPI corriendo. Directorios `temp_files` y `output_transcripts` existen. | `{"youtube_url": "https://www.youtube.com/watch?v=dQw4w9WgXcQ", "title": "rickroll_tc002"}`                           | Código 200. Respuesta JSON con `filename`, `transcription_length`, `detected_language`. Archivo `output_transcripts/rickroll_tc002_vid_dQw4w9WgXcQ_job_XYZ.txt` creado. Archivos de video y audio WAV en `temp_files/` eliminados.       | Código 200. `output_transcripts/rickroll_tc002_vid_dQw4w9WgXcQ_job_XYZ.txt` creado y verificado (transcripción en inglés). Archivos temporales eliminados. | P            | Nombre de archivo final incluye video_id y job_id.                                                                                                                                                                                    |
| TC_003  | `title` sin extensión `.txt` (app debe añadirla)                            | Servidor FastAPI corriendo.                                                         | `{"youtube_url": "https://www.youtube.com/watch?v=Y-Jy_ClFIos", "title": "midutest_noext_tc003"}`                        | Código 200. Archivo `output_transcripts/midutest_noext_tc003.txt` creado.                                                                                                          | Pasa (verificado por análisis de código). `utils.save_transcription_to_file` añade `.txt`. | P            | La normalización del título en `main.py` también se aplica antes.                                                                                                                                                   |
| TC_004  | `title` con caracteres especiales y puntos (app debe normalizarlo)         | Servidor FastAPI corriendo.                                                         | `{"youtube_url": "https://www.youtube.com/watch?v=Y-Jy_ClFIos", "title": "Mi Video.. ¡Con /\:*?<>| Char! .final"}`       | Código 200. Archivo `output_transcripts/Mi_Video_Con_Char_final_vid_Y-Jy_ClFIos_job_XYZ.txt` creado (o similar, con `video_id` y `job_id` reales, según `normalize_title_for_filename` y la lógica de `main.py`). Archivos temp eliminados. | Pasa (verificado por análisis de código). `utils.normalize_title_for_filename` y `save_transcription_to_file` funcionan como se espera. | P            | Nueva función `normalize_title_for_filename` en `utils.py` implementada y usada en `main.py`. El nombre normalizado por `utils.py` es "Mi_Video_Con_Char_final".                                                                                                                     |
| **VALIDACIÓN DE ENTRADA** |                                                                             |                                                                                     |                                                                                                                                   |                                                                                                                                                                                 |                  |              |                                                                                                                                                                                                                   |
| TC_005  | URL de YouTube inválida (formato incorrecto)                                  | Servidor FastAPI corriendo.                                                         | `{"youtube_url": "esto_no_es_una_url", "title": "invalid_url_tc005"}`                                                   | Código 422. Respuesta JSON de error de validación de Pydantic indicando problema con `youtube_url`.                                                                                |                  |              |                                                                                                                                                                                                                   |
| TC_006  | URL no es de YouTube (pero es una URL válida)                               | Servidor FastAPI corriendo.                                                         | `{"youtube_url": "https://www.google.com", "title": "notyoutube_tc006"}`                                                  | Código 503 (debido a `DownloadError` de yt-dlp al no ser video de YT) o 422 si Pydantic lo valida. Actualmente, yt-dlp fallará.                                                  |                  |              | La validación de Pydantic `HttpUrl` solo verifica formato. yt-dlp generará error si no es YT.                                                                                                                      |
| TC_007  | Falta el campo `youtube_url`                                                | Servidor FastAPI corriendo.                                                         | `{"title": "missing_url_tc007"}`                                                                                        | Código 422. Respuesta JSON de error de validación de Pydantic indicando que `youtube_url` es requerido.                                                                           |                  |              |                                                                                                                                                                                                                   |
| TC_008  | Falta el campo `title`                                                      | Servidor FastAPI corriendo.                                                         | `{"youtube_url": "https://www.youtube.com/watch?v=Y-Jy_ClFIos"}`                                                                    | Código 422. Respuesta JSON de error de validación de Pydantic indicando que `title` es requerido.                                                                                | Pasa (Análisis)  | P            |                                                                                                                                                                                                                   |
| TC_009  | `title` que se normaliza a vacío (ej: "/\\:*?<>|")                          | Servidor FastAPI corriendo.                                                         | `{"youtube_url": "https://www.youtube.com/watch?v=Y-Jy_ClFIos", "title": "/\\:*?<>|"}`                                         | Código 200. Archivo `output_transcripts/untitled_vid_Y-Jy_ClFIos_job_XYZ.txt` creado (con `video_id` y `job_id` reales). `normalize_title_for_filename` devuelve "untitled". | Pasa (Análisis)  | P            | `normalize_title_for_filename` devuelve "untitled" si la normalización resulta en vacío. El fallback de `main.py` a "default_title" no se activa en este caso.                                                   |
| **MANEJO DE ERRORES (YT-DLP / FFMPEG)** |                                                                             |                                                                                     |                                                                                                                                   |                                                                                                                                                                                 |                  |              |                                                                                                                                                                                                                   |
| TC_010  | Video de YouTube no existe / es privado                                       | Servidor FastAPI corriendo.                                                         | `{"youtube_url": "https://www.youtube.com/watch?v=INVALIDVIDEOIDNONEXISTENT", "title": "nonexistent_tc010"}`                       | Código 503. `DownloadError` capturada. Mensaje de error de yt-dlp propagado. No se crean archivos de salida. No se crean archivos temporales en `temp_files/` por la app, por lo que la limpieza síncrona no tiene nada que eliminar. | Pasa (Análisis)  | P            | El error ocurre antes de la creación de archivos temporales por nuestra app.                                                                                                                                      |
| TC_011  | Video sin pista de audio disponible (o formato no procesable por Whisper)       | Servidor FastAPI corriendo. Encontrar un video así puede ser difícil.                  | `{"youtube_url": "URL_VIDEO_SIN_AUDIO_VALIDO_PARA_WHISPER", "title": "noaudio_tc011"}`                                                      | Código 503 (si `DownloadError` por fallo en extracción de WAV) o 500 (si `TranscriptionError` por WAV inválido para Whisper). Si el video fue descargado, se limpia de `temp_files/`. Si el WAV fue creado pero es inválido, también se limpia. No se crea archivo de transcripción.                               | Pasa (Análisis)  | P            | El código de error varía según el punto de fallo (extracción o transcripción). Limpieza síncrona de archivos temporales creados (video y/o audio.wav) en `temp_files/` es crucial.                                                                                                                                    |
| **MANEJO DE ERRORES (WHISPER)** |                                                                             |                                                                                     |                                                                                                                                   |                                                                                                                                                                                 |                  |              |                                                                                                                                                                                                                   |
| TC_012  | Archivo de audio corrupto (simulado post-descarga)                            | Servidor FastAPI corriendo. Requeriría modificar `downloader` para que devuelva un .wav corrupto. | (Simular que `downloader.py` devuelve una ruta a un .wav corrupto con `title` "corrupt_audio_tc012", y un video.mp4 asociado)                                                          | Código 500. `TranscriptionError` capturada. Archivos de video y audio WAV temporales en `temp_files/` son eliminados por limpieza síncrona. No se crea archivo de transcripción.                                                                                                                    | Pasa (Análisis)  | P            | Similar a TC_011 (escenario de fallo de transcripción).                                                                                                                                                           |
| **OTROS** |                                                                             |                                                                                     |                                                                                                                                   |                                                                                                                                                                                 |                  |              |                                                                                                                                                                                                                   |
| TC_013  | Video muy corto (pocos segundos)                                             | Servidor FastAPI corriendo.                                                         | `{"youtube_url": "https://www.youtube.com/watch?v=P_20tfBTPgA", "title": "veryshort_tc013"}` (Video de 1 segundo)        | Código 200. Transcripción correcta (puede ser vacía o corta). `detected_language` presente.                                                                                      | Pasa (Análisis)  | P            |                                                                                                                                                                                                                   |
| TC_014  | Peticiones concurrentes (simular varias llamadas a la vez)                    | Servidor FastAPI corriendo. Usar herramienta como `ab` (Apache Benchmark) o script.   | Múltiples POST /transcribe con `title` únicos para cada una.                                                                                                        | Todas las peticiones deberían procesarse correctamente (aunque secuencialmente por el modelo en CPU). Sin errores por concurrencia. Nombres de archivo de salida únicos. Archivos temporales correctamente limpiados para cada tarea.                                                            |                  |              | Observar logs por posible contención de recursos (CPU/GPU, I/O del disco) si el número de trabajadores del pool de hilos de FastAPI se ve superado por las solicitudes concurrentes. El modelo Whisper ahora se carga una vez al inicio, eliminando la sobrecarga de recarga por solicitud. |
| **NUEVOS CASOS / REFINADOS** |                                                                             |                                                                                     |                                                                                                                                   |                                                                                                                                                                                 |                  |              |                                                                                                                                                                                                                   |
| TC_015  | `title` con emojis (app debe normalizarlo, probablemente eliminándolos)     | Servidor FastAPI corriendo.                                                         | `{"youtube_url": "https://www.youtube.com/watch?v=Y-Jy_ClFIos", "title": "Test 😊 con Emojis 👍🎧 TC015"}`               | Código 200. Archivo `output_transcripts/Test_con_Emojis_TC015_vid_Y-Jy_ClFIos_job_XYZ.txt` creado. Emojis eliminados del nombre de archivo. Archivos video/audio WAV en `temp_files/` eliminados. |                  |              | `normalize_title_for_filename` en `utils.py` elimina caracteres no alfanuméricos (incluyendo emojis).                                                                                                                             |
| TC_016  | Video Muy Largo (Podcast 3 horas - Conceptual)                              | Servidor FastAPI corriendo.                                                         | `{"youtube_url": "URL_A_UN_PODCAST_DE_3_HORAS", "title": "LongPodcast_TC016"}`                                           | **Conceptual**: Proceso toma horas. Respuesta HTTP 200 si no hay timeouts externos. Alto uso de CPU/memoria. `yt-dlp` y Whisper deberían manejarlo. Riesgo de timeouts (cliente, Uvicorn, red). **Recomendación**: Para producción, usar colas de tareas asíncronas. Archivos temp (video muy grande, audio WAV muy grande) limpiados al final. |                  |              | Este caso es para análisis teórico de robustez y escalabilidad, no ejecución real.                                                                                                                                  |
| TC_017  | Error Interno Genérico Post-Descarga                                        | Servidor FastAPI corriendo.                                                         | `{"youtube_url": "https://www.youtube.com/watch?v=Y-Jy_ClFIos", "title": "GenericError_TC017"}` (Simular `Exception` en `main.py` después de descarga y transcripción, antes de guardar). | Código 500. Mensaje de error genérico. Archivos de video y audio WAV temporales en `temp_files/` son eliminados por `utils.cleanup_temp_files_sync()`. No se crea archivo de transcripción. |                  |              | Asegura que la limpieza síncrona funcione incluso con errores inesperados.                                                                                                                                           |
| TC_018  | Fallo de Escritura del Archivo de Transcripción (ej. permisos)              | Servidor FastAPI corriendo.                                                         | `{"youtube_url": "https://www.youtube.com/watch?v=Y-Jy_ClFIos", "title": "SaveFail_TC018"}` (Simular que `utils.save_transcription_to_file` falla después de una transcripción exitosa). | Código 500. Mensaje indicando fallo al guardar. Archivos de video y audio WAV temporales en `temp_files/` son eliminados por `utils.cleanup_temp_files_sync()` (ya que la tarea de fondo no se programaría o el error es síncrono). No se crea archivo de transcripción. |                  |              | Verifica el manejo de errores en la fase final de guardado. La limpieza de los archivos temporales sigue siendo crucial.                                                                                                  |

---

## Resumen de la Simulación de Pruebas

### Objetivo y Alcance de la Simulación

El propósito de esta fase de pruebas simuladas fue evaluar la robustez, la funcionalidad principal y el manejo de errores de la aplicación de transcripción de YouTube. La simulación se basó en el análisis del código fuente (`codebase.xml`), la documentación (`README.md`, `PLAN.md`, `analysis_notes.md`) y los casos de prueba definidos en este documento (`TEST.md`). No se realizaron ejecuciones reales contra la API desplegada; en su lugar, se trazó el flujo de ejecución del código para cada caso de prueba, prediciendo el comportamiento y los resultados.

### Metodología

Para cada caso de prueba, se siguió el flujo lógico del código a través de los módulos relevantes (`main.py`, `downloader.py`, `transcriber.py`, `utils.py`):
1.  Análisis de la entrada de la petición.
2.  Simulación del comportamiento de las funciones clave (descarga, extracción, transcripción, guardado).
3.  Evaluación del manejo de errores y excepciones.
4.  Verificación de la lógica de creación y limpieza de archivos temporales y de salida.
5.  Predicción de la respuesta HTTP (código de estado y cuerpo).

## Resultados Generales de la Simulación

La simulación indica que la aplicación es en general robusta y maneja adecuadamente muchos de los escenarios previstos, incluyendo la mayoría de los errores de descarga y transcripción, la normalización de nombres de archivo y la limpieza de archivos temporales. La carga del modelo Whisper al inicio de la aplicación es una buena práctica para el rendimiento.

### Puntos Fuertes Observados

*   **Manejo de Errores de Descarga (`DownloadError`):** La aplicación captura y maneja correctamente los errores provenientes de `yt-dlp` (ej. video no disponible), devolviendo un `503 Service Unavailable`.
*   **Manejo de Errores de Transcripción (`TranscriptionError`):** Los errores durante la fase de transcripción son capturados, resultando en un `500 Internal Server Error`.
*   **Normalización de Nombres de Archivo:** La función `utils.normalize_title_for_filename` y la lógica de nombrado en `main.py` y `utils.save_transcription_to_file` parecen robustas para los casos de uso previstos (incluyendo la eliminación de emojis y caracteres especiales).
*   **Limpieza de Archivos Temporales:** La estrategia dual de limpieza (tareas en segundo plano para casos de éxito y limpieza síncrona para errores) es sólida y cubre la mayoría de los escenarios para evitar archivos residuales en `temp_files/`.
*   **Carga Inicial del Modelo Whisper:** Mejora la latencia de las primeras peticiones y el uso general de recursos.

### Áreas de Mejora Identificadas

Se identificaron dos áreas principales que requieren atención:
1.  Manejo de fallos durante el guardado del archivo de transcripción final.
2.  Consideraciones arquitectónicas para el procesamiento de videos de muy larga duración.

## Hallazgos Detallados y Recomendaciones Específicas

### HALLAZGO CRÍTICO 1 (Ref: TC_018): Manejo inadecuado de fallo en `utils.save_transcription_to_file`

*   **Descripción del Problema Actual:**
    Si la función `utils.save_transcription_to_file` falla (ej., debido a problemas de permisos de disco, disco lleno, etc.), actualmente devuelve `None`. En `main.py`, la variable `output_file_path` recibe este `None`. Sin embargo, el flujo de control no trata esto explícitamente como un error crítico que deba interrumpir la respuesta exitosa. El código procede a construir una respuesta `TranscriptionResponse` (usando un nombre de archivo de fallback) y devuelve un `200 OK`. La limpieza de los archivos temporales (`video_path_temp`, `audio_path_temp`) se realiza mediante una tarea en segundo plano, ya que no se lanzó ninguna excepción en el bloque `try` principal que activaría la limpieza síncrona.

*   **Impacto:**
    La API informa al cliente de un éxito (`200 OK`) y proporciona un nombre de archivo, pero el archivo de transcripción correspondiente no existe en el disco. Esto es engañoso y resulta en una pérdida de datos desde la perspectiva del usuario, a pesar de que la descarga y la transcripción fueron exitosas.

*   **Recomendación Detallada para el Desarrollador:**
    Modificar el endpoint `/transcribe` en `yt_transcriber/main.py` después de la llamada a `utils.save_transcription_to_file`:

    1.  **Verificar el Resultado:** Comprobar si `output_file_path` es `None` después de la llamada a `await run_in_threadpool(utils.save_transcription_to_file, ...)`.
    2.  **Si `output_file_path` es `None` (fallo al guardar):**
        *   **Registrar Error:** `logger.error(f"CRÍTICO: Fallo al guardar el archivo de transcripción para {output_filename_base} en {config.OUTPUT_TRANSCRIPTS_DIR}")`
        *   **Limpieza Síncrona Inmediata:** Ejecutar `utils.cleanup_temp_files_sync([video_path_temp, audio_path_temp])` para asegurar que los archivos temporales (video y audio WAV) se eliminen inmediatamente, ya que la tarea en segundo plano podría no ejecutarse o la aplicación podría terminar.
        *   **Lanzar HTTPException:** `raise HTTPException(status_code=500, detail="Error interno del servidor: No se pudo guardar el archivo de transcripción.")`

    Fragmento de código sugerido en `main.py` (después de la llamada a `save_transcription_to_file`):
    ```python
    # ... (línea anterior: output_file_path = await run_in_threadpool(...))

    if output_file_path is None:
        logger.error(
            f"CRÍTICO: Fallo al guardar el archivo de transcripción para '{output_filename_base}' en '{config.OUTPUT_TRANSCRIPTS_DIR}'"
        )
        # Limpieza síncrona ya que el guardado final falló.
        files_to_clean_on_save_failure = []
        if video_path_temp: # video_path_temp es el path del video descargado
            files_to_clean_on_save_failure.append(video_path_temp)
        if audio_path_temp: # audio_path_temp es el path del audio extraído
            files_to_clean_on_save_failure.append(audio_path_temp)

        if files_to_clean_on_save_failure:
            logger.info(f"Ejecutando limpieza síncrona debido a fallo al guardar transcripción para: {files_to_clean_on_save_failure}")
            utils.cleanup_temp_files_sync(files_to_clean_on_save_failure)

        raise HTTPException(
            status_code=500,
            detail="Error interno del servidor: No se pudo guardar el archivo de transcripción."
        )

    logger.info(f"Transcripción guardada en: {output_file_path}")

    # 5. Programar limpieza de archivos temporales (esto se movería o se eliminaría si la limpieza síncrona ya se hizo)
    # La lógica actual de background_tasks para la limpieza es correcta si el guardado es exitoso.
    # ... (resto del código para la respuesta exitosa)
    ```
    Asegurarse de que la limpieza en `background_tasks` solo se programe si el guardado es exitoso y no se realizó una limpieza síncrona previa debido a este error.

### OBSERVACIÓN IMPORTANTE 1 (Ref: TC_016): Limitaciones con videos de muy larga duración (ej. Podcasts)

*   **Descripción del Problema Conceptual:**
    El diseño actual de la API procesa las solicitudes de transcripción de forma síncrona dentro de un `threadpool`. Para videos muy largos (ej. podcasts de 1 a 4 horas), la descarga, extracción de audio y, especialmente, la transcripción con Whisper (sobre todo en CPU) pueden tomar un tiempo extremadamente largo (potencialmente horas).

*   **Impacto:**
    *   **Timeouts:** Las conexiones HTTP síncronas mantenidas durante tanto tiempo son propensas a timeouts por parte del cliente, el servidor Uvicorn, balanceadores de carga o cualquier proxy intermedio. Esto resultaría en que el cliente reciba un error de timeout, aunque el servidor podría seguir procesando la tarea en segundo plano (si la tarea del threadpool no se cancela).
    *   **Experiencia de Usuario:** Una API que bloquea durante horas no es práctica para la mayoría de los casos de uso.
    *   **Gestión de Recursos:** Tareas muy largas pueden acaparar recursos del servidor (CPU, memoria, hilos del pool) durante periodos prolongados, afectando la capacidad de respuesta para otras solicitudes.

*   **Recomendación Detallada para el Desarrollador:**
    Para manejar robustamente videos de larga duración en un entorno de producción, se recomienda una arquitectura de procesamiento asíncrono:
    1.  **Cola de Tareas:** Implementar un sistema de cola de tareas (ej. Celery con RabbitMQ o Redis como broker).
    2.  **Respuesta Inmediata de la API:** Al recibir una solicitud en `/transcribe`:
        *   Validar la petición.
        *   Encolar la tarea de transcripción (pasando la URL de YouTube y el título).
        *   Responder inmediatamente al cliente con un `202 Accepted` y un ID de tarea.
    3.  **Worker Asíncrono:** Tener procesos *worker* separados que tomen tareas de la cola y ejecuten el pipeline completo de descarga, extracción y transcripción.
    4.  **Almacenamiento de Estado/Resultados:** Los workers almacenarían el resultado (ruta al archivo de transcripción o estado de error) en una base de datos o almacenamiento persistente, asociado con el ID de la tarea.
    5.  **Endpoint de Estado/Resultado:** Implementar un nuevo endpoint (ej. `/transcribe/status/{task_id}`) que el cliente pueda consultar para verificar el progreso o obtener el resultado de la transcripción una vez completada.
    6.  **Notificaciones (Opcional):** Se podrían implementar webhooks o notificaciones para informar al cliente cuando la tarea esté completa.

    Este cambio arquitectónico es significativo pero esencial para la escalabilidad y fiabilidad con tareas de larga duración.

### Otros Casos Relevantes (Éxito y Manejo Adecuado de Errores)

*   **Casos de Éxito (TC_001, TC_002):** La simulación confirma que el flujo principal funciona como se espera, incluyendo la correcta normalización, nombrado de archivos de salida y limpieza de temporales.
*   **Validación de Entradas (TC_005 - TC_009):** FastAPI y Pydantic manejan adecuadamente las entradas inválidas, devolviendo errores `422 Unprocessable Entity`.
*   **Normalización de Títulos con Caracteres Especiales y Emojis (TC_004, TC_015):** La función `utils.normalize_title_for_filename` se comporta correctamente, eliminando caracteres no deseados y produciendo nombres de archivo seguros.
*   **Errores de Descarga y Transcripción (TC_010, TC_011, TC_012):** Estos errores son capturados y manejados, resultando en los códigos HTTP apropiados (`503` o `500`) y la limpieza síncrona de los archivos temporales generados hasta el punto del fallo.
*   **Errores Internos Genéricos (TC_017):** La estructura `try-except Exception` más amplia en `main.py` junto con la limpieza síncrona proporciona una red de seguridad para fallos inesperados después de la creación de archivos temporales.

## Veredicto General de la Simulación

La aplicación demuestra una base sólida y un buen manejo de muchos escenarios. El código está bien estructurado y sigue buenas prácticas en cuanto a modularidad y configuración. Los mecanismos de limpieza de archivos son robustos para la mayoría de los fallos simulados.

Sin embargo, la simulación ha identificado un **defecto crítico** en el manejo de errores de guardado de archivos (TC_018) que debe ser corregido para asegurar la integridad de los datos y la correcta comunicación de estado al cliente. Adicionalmente, se ha destacado una **limitación arquitectónica** importante con respecto al procesamiento de videos muy largos (TC_016), que requerirá un rediseño a un modelo asíncrono para un uso robusto en producción con dicho tipo de contenido.

Con la corrección del defecto crítico y la consideración de la recomendación arquitectónica para tareas largas, la aplicación estará en una posición mucho más fuerte.

## Recomendaciones Clave (Priorizadas)

1.  **CRÍTICO - Corregir Manejo de Fallo en Guardado de Transcripción (TC_018):** Implementar la verificación del resultado de `utils.save_transcription_to_file` en `main.py`. Si falla, lanzar `HTTPException 500` y realizar limpieza síncrona de archivos temporales. (Ver detalles en HALLAZGO CRÍTICO 1).
2.  **IMPORTANTE (Para Escalabilidad con Podcasts) - Considerar Arquitectura Asíncrona (TC_016):** Para el procesamiento de videos de larga duración, planificar la migración a un sistema de colas de tareas (ej. Celery) para desacoplar el procesamiento de la solicitud HTTP inicial. (Ver detalles en OBSERVACIÓN IMPORTANTE 1).
3.  **Revisión General:** Aunque la limpieza de archivos es mayormente robusta, una revisión adicional de todos los flujos de error para confirmar que `cleanup_temp_files_sync` se llama siempre que se hayan creado archivos temporales y el proceso no pueda completarse exitosamente (incluyendo el guardado del archivo final) sería beneficiosa.
